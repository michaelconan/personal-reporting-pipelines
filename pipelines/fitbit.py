"""
fitbit.py

Pipeline to load data from FitBit using Web API.

OAuth2 access and refresh token can be generated by following this `tutorial`_.

.. _tutorial: https://dev.fitbit.com/build/reference/web-api/troubleshooting-guide/oauth2-tutorial/

API Resources:

- `List Activities <https://dev.fitbit.com/build/reference/web-api/activity/get-activity-log-list/>`_
- `List Sleep <https://dev.fitbit.com/build/reference/web-api/sleep/get-sleep-log-list/>`_
"""

# Base
from logging import getLogger, Logger

# PyPI
import requests
from google.cloud import secretmanager_v1
import google.auth

# dlt
import dlt
from dlt.sources.rest_api import rest_api_source
from dlt.sources.helpers.rest_client.paginators import (
    OffsetPaginator,
)
from dlt.common.pipeline import LoadInfo

# Common custom tasks
from pipelines import RAW_SCHEMA, BASE_DATE
from pipelines.common.utils import (
    get_refresh_mode,
    get_write_disposition,
    log_refresh_mode,
)


logger: Logger = getLogger(__name__)


def get_fitbit_token() -> str:
    """Get a fresh Fitbit API access token using the stored refresh token.

    This function requests a new access token from Fitbit's OAuth2 endpoint
    using the refresh token stored in DLT secrets. It also updates the
    refresh token in Google Secret Manager for future use.

    Returns:
        str: The new access token for Fitbit API requests.

    Raises:
        requests.HTTPError: If the token refresh request fails.
    """
    # Request refreshed tokens
    resp = requests.post(
        "https://api.fitbit.com/oauth2/token",
        auth=requests.auth.HTTPBasicAuth(
            dlt.secrets["sources.fitbit.client_id"],
            dlt.secrets["sources.fitbit.client_secret"],
        ),
        data={
            "grant_type": "refresh_token",
            "refresh_token": dlt.secrets["sources.fitbit.refresh_token"],
        },
    )
    resp.raise_for_status()
    result = resp.json()

    # Connect to Google Cloud Secret Manager
    _, project_id = google.auth.default()
    client = secretmanager_v1.SecretManagerServiceClient()
    parent = client.secret_path(project_id, "sources-fitbit-refresh_token")

    # Update secret manager with refresh token for next run
    client.add_secret_version(
        request={
            "parent": parent,
            "payload": {
                "data": result["refresh_token"].encode("UTF-8"),
            },
        }
    )

    return result["access_token"]


def fitbit_source(
    api_key: str,
    initial_date: str = BASE_DATE,
    session: requests.Session | None = None,
    end_date: str | None = None,
) -> dlt.sources.rest_api.rest_api_source:
    """Create a DLT source for Fitbit API data.

    This function configures and returns a DLT source for extracting sleep and
    activity data from the Fitbit Web API.

    Args:
        api_key (str): Fitbit API access token for authentication.
        initial_date (str, optional): Start date for data extraction in
            YYYY-MM-DD format. Defaults to `BASE_DATE`.
        session (requests.Session, optional): Optional requests session for
            HTTP calls. Defaults to None.
        end_date (str, optional): Optional end date for data extraction in
            YYYY-MM-DD format. Defaults to None.

    Returns:
        dlt.sources.rest_api.rest_api_source: dlt source configured for Fitbit
            data extraction.
    """
    api_config = {
        "client": {
            "base_url": "https://api.fitbit.com/",
            "auth": {
                "type": "bearer",
                "token": api_key,
            },
            "headers": {
                "Content-Type": "application/json",
            },
        },
        "resource_defaults": {
            "write_disposition": "append",
        },
        "resources": [
            {
                "name": "fitbit__sleep",
                "max_table_nesting": 1,
                "endpoint": {
                    "path": "1.2/user/-/sleep/list.json",
                    "method": "GET",
                    "data_selector": "sleep",
                    "params": {
                        "sort": "asc",
                        "afterDate": "{incremental.start_value}",
                    },
                    "paginator": OffsetPaginator(
                        limit=100,
                        limit_param="limit",
                        offset_param="offset",
                        total_path=None,
                    ),
                    "incremental": {
                        "cursor_path": "dateOfSleep",
                        "initial_value": initial_date,
                        "end_value": end_date,
                    },
                },
            },
            {
                "name": "fitbit__activities",
                "max_table_nesting": 1,
                "columns": {"activity_level": {"data_type": "json"}},
                "endpoint": {
                    "path": "1/user/-/activities/list.json",
                    "method": "GET",
                    "data_selector": "activities",
                    "params": {
                        "sort": "asc",
                        "afterDate": "{incremental.start_value}",
                    },
                    "paginator": OffsetPaginator(
                        limit=100,
                        limit_param="limit",
                        offset_param="offset",
                        total_path=None,
                    ),
                    "incremental": {
                        "cursor_path": "lastModified",
                        "initial_value": initial_date,
                        "end_value": end_date,
                        "convert": lambda d: d[:10],
                    },
                },
            },
        ],
    }
    if session:
        api_config["client"]["session"] = session

    return rest_api_source(api_config)


def refresh_fitbit(
    is_incremental: bool | None = None,
    pipeline: dlt.Pipeline | None = None,
    initial_date: str | None = BASE_DATE,
    end_date: str | None = None,
) -> LoadInfo:
    """Refresh Fitbit health data pipeline.

    Args:
        is_incremental (bool, optional): Override incremental mode.
            If None, uses environment-based detection. Defaults to None.
        pipeline (dlt.Pipeline, optional): dlt pipeline object.
            If None, a new one is created. Defaults to None.
        initial_date (str, optional): The start date for the data extraction.
            Defaults to `BASE_DATE`.
        end_date (str, optional): The end date for the data extraction.
            Defaults to None.

    Returns:
        dlt.common.pipeline.LoadInfo: Pipeline run information and status.
    """

    # Determine refresh mode if not explicitly provided
    if is_incremental is None:
        is_incremental = get_refresh_mode(default_incremental=True)

    # Log the refresh mode being used
    log_refresh_mode("Fitbit Health", is_incremental, RAW_SCHEMA)

    # define the data load tool pipeline for tasks
    pipeline_name = "fitbit_health_pipeline"

    # create fitbit dlt source
    fb_token = get_fitbit_token()
    fb_source = fitbit_source(
        api_key=fb_token,
        initial_date=initial_date,
        end_date=end_date,
    )

    if not pipeline:
        # Modify the pipeline parameters
        pipeline = dlt.pipeline(
            pipeline_name=pipeline_name,
            # TODO: Sort out how to define schema using params
            dataset_name=RAW_SCHEMA,
            destination="bigquery",
        )

    # Get appropriate write disposition
    write_disposition = get_write_disposition(is_incremental)

    # serialise the pipeline into airflow tasks
    info = pipeline.run(
        fb_source,
        write_disposition=write_disposition,
    )
    logger.info(info)
    return info


if __name__ == "__main__":
    info = refresh_fitbit()
    logger.info(info)
